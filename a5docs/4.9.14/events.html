<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >Events</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><script type="text/javascript" src="autosuggest.js"></script>
<script type="text/javascript" src="search_index.js"></script>
<link rel="stylesheet" href="pandoc.css" type="text/css" media="all" />
</head
  ><body
  ><table class="white">
<tr>
<td valign="top" class="sidebar">

<div class="sidebar">
<ul
><li
  ><a href="index.html"
    ><strong
      >Contents</strong
      ></a
    ></li
  ><li
  ><a href="config.html"
    >Configuration files</a
    ></li
  ><li
  ><a href="display.html"
    >Display</a
    ></li
  ><li
  ><a href="events.html"
    >Events</a
    ></li
  ><li
  ><a href="file.html"
    >File I/O</a
    ></li
  ><li
  ><a href="fshook.html"
    >Filesystem</a
    ></li
  ><li
  ><a href="fixed.html"
    >Fixed</a
    ></li
  ><li
  ><a href="graphics.html"
    >Graphics</a
    ></li
  ><li
  ><a href="joystick.html"
    >Joystick</a
    ></li
  ><li
  ><a href="keyboard.html"
    >Keyboard</a
    ></li
  ><li
  ><a href="memory.html"
    >Memory</a
    ></li
  ><li
  ><a href="misc.html"
    >Miscellaneous</a
    ></li
  ><li
  ><a href="mouse.html"
    >Mouse</a
    ></li
  ><li
  ><a href="opengl.html"
    >OpenGL</a
    ></li
  ><li
  ><a href="path.html"
    >Path</a
    ></li
  ><li
  ><a href="platform.html"
    >Platform-specific</a
    ></li
  ><li
  ><a href="state.html"
    >State</a
    ></li
  ><li
  ><a href="system.html"
    >System</a
    ></li
  ><li
  ><a href="threads.html"
    >Threads</a
    ></li
  ><li
  ><a href="time.html"
    >Time</a
    ></li
  ><li
  ><a href="timer.html"
    >Timer</a
    ></li
  ><li
  ><a href="utf8.html"
    >UTF-8</a
    ></li
  ><li
  ><a href="index.html#addons"
    ><strong
      >Addons</strong
      ></a
    ></li
  ><li
  ><a href="audio.html"
    >Audio addon</a
    ></li
  ><li
  ><a href="acodec.html"
    >Audio codecs</a
    ></li
  ><li
  ><a href="color.html"
    >Color addon</a
    ></li
  ><li
  ><a href="font.html"
    >Font addons</a
    ></li
  ><li
  ><a href="image.html"
    >Image I/O addon</a
    ></li
  ><li
  ><a href="native_dialog.html"
    >Native dialogs addon</a
    ></li
  ><li
  ><a href="physfs.html"
    >PhysicsFS addon</a
    ></li
  ><li
  ><a href="primitives.html"
    >Primitives addon</a
    ></li
  ></ul
><!-- keep blank line for correct HTML -->
</div>

<div class="searchbox">
<script type="text/javascript">
function onSubmit(form) {
    for (i = 0; i < search_index.length; i++) {
        if (search_index[i] == form.q.value) {
            form.action = search_urls[i];
            form.method = "POST";
            return true;
        }
    }
    // Search-term is not in the index.
    // We could add an URL here which does a fulltext search - for
    // now we simply do nothing by return false to the form.
    return false;
}
</script>
<form id="search" action="search.py" onsubmit="return onSubmit(this);"><input type="text" name="q" id="q" size="15" autocomplete="off" /><br /> <input type="submit" value="Search" /><script type="text/javascript">actb = new actb("q", search_index);</script>
</form>
</div>


</td>
<td class="content">


<h1 class="title"
    >Events</h1
    ><div id="toc"
    ><ul
      ><li
	><a href="#allegro_event" id="TOC-allegro_event"
	  >ALLEGRO_EVENT</a
	  ></li
	><li
	><a href="#allegro_user_event" id="TOC-allegro_user_event"
	  >ALLEGRO_USER_EVENT</a
	  ></li
	><li
	><a href="#allegro_event_queue" id="TOC-allegro_event_queue"
	  >ALLEGRO_EVENT_QUEUE</a
	  ></li
	><li
	><a href="#allegro_event_source" id="TOC-allegro_event_source"
	  >ALLEGRO_EVENT_SOURCE</a
	  ></li
	><li
	><a href="#allegro_event_type" id="TOC-allegro_event_type"
	  >ALLEGRO_EVENT_TYPE</a
	  ></li
	><li
	><a href="#allegro_get_event_type" id="TOC-allegro_get_event_type"
	  >ALLEGRO_GET_EVENT_TYPE</a
	  ></li
	><li
	><a href="#allegro_event_type_is_user" id="TOC-allegro_event_type_is_user"
	  >ALLEGRO_EVENT_TYPE_IS_USER</a
	  ></li
	><li
	><a href="#al_create_event_queue" id="TOC-al_create_event_queue"
	  >al_create_event_queue</a
	  ></li
	><li
	><a href="#al_init_user_event_source" id="TOC-al_init_user_event_source"
	  >al_init_user_event_source</a
	  ></li
	><li
	><a href="#al_destroy_event_queue" id="TOC-al_destroy_event_queue"
	  >al_destroy_event_queue</a
	  ></li
	><li
	><a href="#al_destroy_user_event_source" id="TOC-al_destroy_user_event_source"
	  >al_destroy_user_event_source</a
	  ></li
	><li
	><a href="#al_drop_next_event" id="TOC-al_drop_next_event"
	  >al_drop_next_event</a
	  ></li
	><li
	><a href="#al_emit_user_event" id="TOC-al_emit_user_event"
	  >al_emit_user_event</a
	  ></li
	><li
	><a href="#al_event_queue_is_empty" id="TOC-al_event_queue_is_empty"
	  >al_event_queue_is_empty</a
	  ></li
	><li
	><a href="#al_flush_event_queue" id="TOC-al_flush_event_queue"
	  >al_flush_event_queue</a
	  ></li
	><li
	><a href="#al_get_next_event" id="TOC-al_get_next_event"
	  >al_get_next_event</a
	  ></li
	><li
	><a href="#al_peek_next_event" id="TOC-al_peek_next_event"
	  >al_peek_next_event</a
	  ></li
	><li
	><a href="#al_register_event_source" id="TOC-al_register_event_source"
	  >al_register_event_source</a
	  ></li
	><li
	><a href="#al_unref_user_event" id="TOC-al_unref_user_event"
	  >al_unref_user_event</a
	  ></li
	><li
	><a href="#al_unregister_event_source" id="TOC-al_unregister_event_source"
	  >al_unregister_event_source</a
	  ></li
	><li
	><a href="#al_wait_for_event" id="TOC-al_wait_for_event"
	  >al_wait_for_event</a
	  ></li
	><li
	><a href="#al_wait_for_event_timed" id="TOC-al_wait_for_event_timed"
	  >al_wait_for_event_timed</a
	  ></li
	><li
	><a href="#al_wait_for_event_until" id="TOC-al_wait_for_event_until"
	  >al_wait_for_event_until</a
	  ></li
	></ul
      ></div
    ><h1 id="allegro_event"
    ><a href="#TOC-allegro_event"
      >ALLEGRO_EVENT</a
      ></h1
    ><pre
    ><code
      >typedef union ALLEGRO_EVENT ALLEGRO_EVENT;
</code
      ></pre
    ><p
    >An ALLEGRO_EVENT is a union of all builtin event structures, i.e. it is an object large enough to hold the data of any event type. All events have the following fields in common:</p
    ><pre
    ><code
      >ALLEGRO_EVENT_TYPE          type;
ALLEGRO_EVENT_SOURCE *      any.source;
double                      any.timestamp;
</code
      ></pre
    ><p
    >By examining the type field you can then access type-specific fields. The any.source field tells you which event source generated that particular event. The any.timestamp field tells you when the event was generated. The time is referenced to the same starting point as al_current_time().</p
    ><p
    >Each event is of one of the following types:</p
    ><ul
    ><li
      ><p
	>ALLEGRO_EVENT_JOYSTICK_AXIS - a joystick axis value changed.</p
	>Fields are:<ul
	><li
	  >joystick.stick,</li
	  ><li
	  >joystick.axis,</li
	  ><li
	  >joystick.pos (-1.0 to 1.0).</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN - a joystick button was pressed.</p
	>Fields are:<ul
	><li
	  >joystick.button.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_JOYSTICK_BUTTON_UP - a joystick button was released.</p
	>Fields are:<ul
	><li
	  >joystick.button.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_KEY_DOWN - a keyboard key was pressed.</p
	>Fields:<ul
	><li
	  >keyboard.keycode,</li
	  ><li
	  >keyboard.unichar,</li
	  ><li
	  >keyboard.modifiers,</li
	  ><li
	  >keyboard.display.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_KEY_REPEAT - a typed character auto-repeated.</p
	>Fields:<ul
	><li
	  >keyboard.keycode (ALLEGRO_KEY_*),</li
	  ><li
	  >keyboard.unichar (unicode character),</li
	  ><li
	  >keyboard.modifiers (ALLEGRO_KEYMOD_*),</li
	  ><li
	  >keyboard.display.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_KEY_UP - a keyboard key was released.</p
	>Fields:<ul
	><li
	  >keyboard.keycode,</li
	  ><li
	  >keyboard.display.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_MOUSE_AXES - one or more mouse axis values changed.</p
	>Fields:<ul
	><li
	  >mouse.x,</li
	  ><li
	  >mouse.y,</li
	  ><li
	  >mouse.z,</li
	  ><li
	  >mouse.dx,</li
	  ><li
	  >mouse.dy,</li
	  ><li
	  >mouse.dz,</li
	  ><li
	  >mouse.display.</li
	  ></ul
	><p
	>Note: Calling <a href="mouse.html#al_set_mouse_xy"
	  >al_set_mouse_xy</a
	  > also will result in a change of axis values, but such a change is reported with ALLEGRO_EVENT_MOUSE_WARPED events instead.</p
	><p
	>Note: currently mouse.display may be NULL if an event is generated in response to <a href="mouse.html#al_set_mouse_axis"
	  >al_set_mouse_axis</a
	  >.</p
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_MOUSE_BUTTON_DOWN - a mouse button was pressed.</p
	>Fields:<ul
	><li
	  >mouse.x,</li
	  ><li
	  >mouse.y,</li
	  ><li
	  >mouse.z,</li
	  ><li
	  >mouse.button,</li
	  ><li
	  >mouse.display.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_MOUSE_BUTTON_UP - a mouse button was released.</p
	>Fields:<ul
	><li
	  >mouse.x,</li
	  ><li
	  >mouse.y,</li
	  ><li
	  >mouse.z,</li
	  ><li
	  >mouse.button,</li
	  ><li
	  >mouse.display.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_MOUSE_WARPED - <a href="mouse.html#al_set_mouse_xy"
	  >al_set_mouse_xy</a
	  > was called to move the mouse. This event is identical to ALLEGRO_EVENT_MOUSE_AXES otherwise.</p
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY - the mouse cursor entered a window opened by the program.</p
	>Fields:<ul
	><li
	  >mouse.x,</li
	  ><li
	  >mouse.y,</li
	  ><li
	  >mouse.z,</li
	  ><li
	  >mouse.display.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_MOUSE_LEAVE_DISPLAY - the mouse cursor leave the boundaries of a window opened by the program.</p
	>Fields:<ul
	><li
	  >mouse.x,</li
	  ><li
	  >mouse.y,</li
	  ><li
	  >mouse.z,</li
	  ><li
	  >mouse.display.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_TIMER - a timer counter incremented.</p
	>Fields:<ul
	><li
	  >timer.count.</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_DISPLAY_EXPOSE - The display (or a portion thereof) has become visible. Note: The display needs to be created with ALLEGRO_GENERATE_EXPOSE_EVENTS flag.</p
	>Fields:<ul
	><li
	  >display.x,</li
	  ><li
	  >display.y,</li
	  ><li
	  >display.width,</li
	  ><li
	  >display.height</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_DISPLAY_RESIZE - The window has been resized.</p
	>Fields:<ul
	><li
	  >display.x,</li
	  ><li
	  >display.y,</li
	  ><li
	  >display.width,</li
	  ><li
	  >display.height</li
	  ></ul
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_DISPLAY_CLOSE - The close button of the window has been pressed.</p
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_DISPLAY_LOST - Displays can be lost with some drivers (just Direct3D?). This means that rendering is impossible. The device will be restored as soon as it is possible. The program should be able to ignore this event and continue rendering however it will have no effect.</p
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_DISPLAY_FOUND - Generated when a lost device is regained. Drawing will no longer be a no-op.</p
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_DISPLAY_SWITCH_OUT - The window is no longer active, that is the user might have clicked into another window or &quot;tabbed&quot; away.</p
	></li
      ><li
      ><p
	>ALLEGRO_EVENT_DISPLAY_SWITCH_IN - The window is the active one again.</p
	></li
      ></ul
    ><p
    >See also: <a href="events.html#allegro_event_source"
      >ALLEGRO_EVENT_SOURCE</a
      >, <a href="events.html#allegro_event_type"
      >ALLEGRO_EVENT_TYPE</a
      >, <a href="events.html#allegro_user_event"
      >ALLEGRO_USER_EVENT</a
      ></p
    ><h1 id="allegro_user_event"
    ><a href="#TOC-allegro_user_event"
      >ALLEGRO_USER_EVENT</a
      ></h1
    ><pre
    ><code
      >typedef struct ALLEGRO_USER_EVENT ALLEGRO_USER_EVENT;
</code
      ></pre
    ><p
    >An event structure that can be emitted by user event sources. These are the public fields:</p
    ><pre
    ><code
      >ALLEGRO_EVENT_SOURCE *source;
intptr_t data1;
intptr_t data2;
intptr_t data3;
intptr_t data4;
</code
      ></pre
    ><p
    >See also: <a href="events.html#al_emit_user_event"
      >al_emit_user_event</a
      ></p
    ><h1 id="allegro_event_queue"
    ><a href="#TOC-allegro_event_queue"
      >ALLEGRO_EVENT_QUEUE</a
      ></h1
    ><pre
    ><code
      >typedef struct ALLEGRO_EVENT_QUEUE ALLEGRO_EVENT_QUEUE;
</code
      ></pre
    ><p
    >An event queue holds events that have been generated by event sources that are registered with the queue. Events are stored in the order they are generated. Access is in a strictly FIFO (first-in-first-out) order.</p
    ><p
    >See also: <a href="events.html#al_create_event_queue"
      >al_create_event_queue</a
      >, <a href="events.html#al_destroy_event_queue"
      >al_destroy_event_queue</a
      ></p
    ><h1 id="allegro_event_source"
    ><a href="#TOC-allegro_event_source"
      >ALLEGRO_EVENT_SOURCE</a
      ></h1
    ><pre
    ><code
      >typedef struct ALLEGRO_EVENT_SOURCE ALLEGRO_EVENT_SOURCE;
</code
      ></pre
    ><p
    >An event source is any object which can generate events. For example, an ALLEGRO_DISPLAY can generate events, and you can get the ALLEGRO_EVENT_SOURCE pointer from an ALLEGRO_DISPLAY with <a href="display.html#al_get_display_event_source"
      >al_get_display_event_source</a
      >.</p
    ><p
    >You may create your own &quot;user&quot; event sources that emit custom events.</p
    ><p
    >See also: <a href="events.html#allegro_event"
      >ALLEGRO_EVENT</a
      >, <a href="events.html#al_init_user_event_source"
      >al_init_user_event_source</a
      >, <a href="events.html#al_emit_user_event"
      >al_emit_user_event</a
      ></p
    ><h1 id="allegro_event_type"
    ><a href="#TOC-allegro_event_type"
      >ALLEGRO_EVENT_TYPE</a
      ></h1
    ><pre
    ><code
      >typedef unsigned int ALLEGRO_EVENT_TYPE;
</code
      ></pre
    ><p
    >An integer used to distinguish between different types of events.</p
    ><p
    >See also: <a href="events.html#allegro_event"
      >ALLEGRO_EVENT</a
      >, <a href="events.html#allegro_get_event_type"
      >ALLEGRO_GET_EVENT_TYPE</a
      >, <a href="events.html#allegro_event_type_is_user"
      >ALLEGRO_EVENT_TYPE_IS_USER</a
      ></p
    ><h1 id="allegro_get_event_type"
    ><a href="#TOC-allegro_get_event_type"
      >ALLEGRO_GET_EVENT_TYPE</a
      ></h1
    ><pre
    ><code
      >#define ALLEGRO_GET_EVENT_TYPE(a, b, c, d)   AL_ID(a, b, c, d)
</code
      ></pre
    ><p
    >Make an event type identifier, which is a 32-bit integer. Usually this will be made from four 8-bit character codes, for example:</p
    ><pre
    ><code
      >#define MY_EVENT_TYPE   ALLEGRO_GET_EVENT_TYPE('M','I','N','E')
</code
      ></pre
    ><p
    >You should try to make your IDs unique so they don't clash with any 3rd party code you may be using.</p
    ><p
    >IDs less than 1024 are reserved for Allegro or its addons.</p
    ><p
    >See also: <a href="events.html#allegro_event"
      >ALLEGRO_EVENT</a
      >, <a href="events.html#allegro_event_type_is_user"
      >ALLEGRO_EVENT_TYPE_IS_USER</a
      ></p
    ><h1 id="allegro_event_type_is_user"
    ><a href="#TOC-allegro_event_type_is_user"
      >ALLEGRO_EVENT_TYPE_IS_USER</a
      ></h1
    ><pre
    ><code
      >#define ALLEGRO_EVENT_TYPE_IS_USER(t)        ((t) &gt;= 512)
</code
      ></pre
    ><p
    >A macro which evaluates to true if the event type is not a builtin event type, i.e. one of those described in <a href="events.html#allegro_event_type"
      >ALLEGRO_EVENT_TYPE</a
      >.</p
    ><h1 id="al_create_event_queue"
    ><a href="#TOC-al_create_event_queue"
      >al_create_event_queue</a
      ></h1
    ><pre
    ><code
      >ALLEGRO_EVENT_QUEUE *al_create_event_queue(void)
</code
      ></pre
    ><p
    >Create a new, empty event queue, returning a pointer to object if successful. Returns NULL on error.</p
    ><p
    >See also: <a href="events.html#allegro_event_queue"
      >ALLEGRO_EVENT_QUEUE</a
      ></p
    ><h1 id="al_init_user_event_source"
    ><a href="#TOC-al_init_user_event_source"
      >al_init_user_event_source</a
      ></h1
    ><pre
    ><code
      >void al_init_user_event_source(ALLEGRO_EVENT_SOURCE *src)
</code
      ></pre
    ><p
    >Initialise an event source for emitting user events. The space for the event source must already have been allocated.</p
    ><p
    >One possible way of creating custom event sources is to derive other structures with ALLEGRO_EVENT_SOURCE at the head, e.g.</p
    ><pre
    ><code
      >typedef struct THING THING;

struct THING {
    ALLEGRO_EVENT_SOURCE event_source;
    int field1;
    int field2;
    /* etc. */
};

THING *create_thing(void)
{
    THING *thing = malloc(sizeof(THING));

    if (thing) {
        al_init_user_event_source(&amp;thing-&gt;event_source);
        thing-&gt;field1 = 0;
        thing-&gt;field2 = 0;
    }

    return thing;
}
</code
      ></pre
    ><p
    >The advantage here is that the THING pointer will be the same as the ALLEGRO_EVENT_SOURCE pointer. Events emitted by the event source will have the event source pointer as the <code
      >source</code
      > field, from which you can get a pointer to a THING by a simple cast (after ensuring checking the event is of the correct type).</p
    ><p
    >However, it is only one technique and you are not obliged to use it.</p
    ><p
    >See also: <a href="events.html#allegro_event_source"
      >ALLEGRO_EVENT_SOURCE</a
      >, <a href="events.html#al_emit_user_event"
      >al_emit_user_event</a
      >, <a href="events.html#al_destroy_user_event_source"
      >al_destroy_user_event_source</a
      ></p
    ><h1 id="al_destroy_event_queue"
    ><a href="#TOC-al_destroy_event_queue"
      >al_destroy_event_queue</a
      ></h1
    ><pre
    ><code
      >void al_destroy_event_queue(ALLEGRO_EVENT_QUEUE *queue)
</code
      ></pre
    ><p
    >Destroy the event queue specified. All event sources currently registered with the queue will be automatically unregistered before the queue is destroyed.</p
    ><p
    >See also: <a href="events.html#allegro_event_queue"
      >ALLEGRO_EVENT_QUEUE</a
      ></p
    ><h1 id="al_destroy_user_event_source"
    ><a href="#TOC-al_destroy_user_event_source"
      >al_destroy_user_event_source</a
      ></h1
    ><pre
    ><code
      >void al_destroy_user_event_source(ALLEGRO_EVENT_SOURCE *src)
</code
      ></pre
    ><p
    >Destroy an event source initialised with <a href="events.html#al_init_user_event_source"
      >al_init_user_event_source</a
      >.</p
    ><p
    >See also: <a href="events.html#allegro_event_source"
      >ALLEGRO_EVENT_SOURCE</a
      ></p
    ><h1 id="al_drop_next_event"
    ><a href="#TOC-al_drop_next_event"
      >al_drop_next_event</a
      ></h1
    ><pre
    ><code
      >bool al_drop_next_event(ALLEGRO_EVENT_QUEUE *queue)
</code
      ></pre
    ><p
    >Drop the next event from the queue. If the queue is empty, nothing happens. Returns true iff an event was dropped.</p
    ><h1 id="al_emit_user_event"
    ><a href="#TOC-al_emit_user_event"
      >al_emit_user_event</a
      ></h1
    ><pre
    ><code
      >bool al_emit_user_event(ALLEGRO_EVENT_SOURCE *src,
   ALLEGRO_EVENT *event, void (*dtor)(ALLEGRO_USER_EVENT *))
</code
      ></pre
    ><p
    >Emit a user event. The event source must have been initialised with <a href="events.html#al_init_user_event_source"
      >al_init_user_event_source</a
      >. Some fields of the event being passed in may be modified. Returns <code
      >false</code
      > if the event source isn't registered with any queues, hence the event wouldn't have been delivered into any queues.</p
    ><p
    >Reference counting will be performed on the event if <code
      >dtor</code
      > is non-NULL. When the reference count drops to zero <code
      >dtor</code
      > will be called with a copy of the event as an argument. It should free the resources associated with the event. If <code
      >dtor</code
      > is NULL then reference counting will not be performed.</p
    ><p
    >You need to call <a href="events.html#al_unref_user_event"
      >al_unref_user_event</a
      > when you are done with a reference counted user event that you have gotten from <a href="events.html#al_get_next_event"
      >al_get_next_event</a
      >, <a href="events.html#al_peek_next_event"
      >al_peek_next_event</a
      >, <a href="events.html#al_wait_for_event"
      >al_wait_for_event</a
      >, etc. You may, but do not need to, call <a href="events.html#al_unref_user_event"
      >al_unref_user_event</a
      > on non-reference counted user events.</p
    ><p
    >See also: <a href="events.html#allegro_user_event"
      >ALLEGRO_USER_EVENT</a
      ></p
    ><h1 id="al_event_queue_is_empty"
    ><a href="#TOC-al_event_queue_is_empty"
      >al_event_queue_is_empty</a
      ></h1
    ><pre
    ><code
      >bool al_event_queue_is_empty(ALLEGRO_EVENT_QUEUE *queue)
</code
      ></pre
    ><p
    >Return true if the event queue specified is currently empty.</p
    ><h1 id="al_flush_event_queue"
    ><a href="#TOC-al_flush_event_queue"
      >al_flush_event_queue</a
      ></h1
    ><pre
    ><code
      >void al_flush_event_queue(ALLEGRO_EVENT_QUEUE *queue)
</code
      ></pre
    ><p
    >Drops all events, if any, from the queue.</p
    ><h1 id="al_get_next_event"
    ><a href="#TOC-al_get_next_event"
      >al_get_next_event</a
      ></h1
    ><pre
    ><code
      >bool al_get_next_event(ALLEGRO_EVENT_QUEUE *queue, ALLEGRO_EVENT *ret_event)
</code
      ></pre
    ><p
    >Take the next event out of the event queue specified, and copy the contents into <code
      >ret_event</code
      >, returning true. The original event will be removed from the queue. If the event queue is empty, return false and the contents of <code
      >ret_event</code
      > are unspecified.</p
    ><p
    >See also: <a href="events.html#allegro_event"
      >ALLEGRO_EVENT</a
      ></p
    ><h1 id="al_peek_next_event"
    ><a href="#TOC-al_peek_next_event"
      >al_peek_next_event</a
      ></h1
    ><pre
    ><code
      >bool al_peek_next_event(ALLEGRO_EVENT_QUEUE *queue, ALLEGRO_EVENT *ret_event)
</code
      ></pre
    ><p
    >Copy the contents of the next event in the event queue specified into <code
      >ret_event</code
      > and return true. The original event packet will remain at the head of the queue. If the event queue is actually empty, this function returns false and the contents of <code
      >ret_event</code
      > are unspecified.</p
    ><p
    >See also: <a href="events.html#allegro_event"
      >ALLEGRO_EVENT</a
      ></p
    ><h1 id="al_register_event_source"
    ><a href="#TOC-al_register_event_source"
      >al_register_event_source</a
      ></h1
    ><pre
    ><code
      >void al_register_event_source(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT_SOURCE *source)
</code
      ></pre
    ><p
    >Register the event source with the event queue specified. An event source may be registered with any number of event queues simultaneously, or none. Trying to register an event source with the same event queue more than once does nothing.</p
    ><p
    >See also: <a href="events.html#allegro_event_queue"
      >ALLEGRO_EVENT_QUEUE</a
      >, <a href="events.html#allegro_event_source"
      >ALLEGRO_EVENT_SOURCE</a
      ></p
    ><h1 id="al_unref_user_event"
    ><a href="#TOC-al_unref_user_event"
      >al_unref_user_event</a
      ></h1
    ><pre
    ><code
      >void al_unref_user_event(ALLEGRO_USER_EVENT *event)
</code
      ></pre
    ><p
    >Unreference a user-defined event. This must be called on any user event that you get from <a href="events.html#al_get_next_event"
      >al_get_next_event</a
      >, <a href="events.html#al_peek_next_event"
      >al_peek_next_event</a
      >, <a href="events.html#al_wait_for_event"
      >al_wait_for_event</a
      >, etc. which is reference counted. This function does nothing if the event is not reference counted.</p
    ><p
    >See also: <a href="events.html#al_emit_user_event"
      >al_emit_user_event</a
      >.</p
    ><h1 id="al_unregister_event_source"
    ><a href="#TOC-al_unregister_event_source"
      >al_unregister_event_source</a
      ></h1
    ><pre
    ><code
      >void al_unregister_event_source(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT_SOURCE *source)
</code
      ></pre
    ><p
    >Unregister an event source with an event queue. If the event source is not actually registered with the event queue, nothing happens.</p
    ><p
    >If the queue had any events in it which originated from the event source, they will no longer be in the queue after this call.</p
    ><h1 id="al_wait_for_event"
    ><a href="#TOC-al_wait_for_event"
      >al_wait_for_event</a
      ></h1
    ><pre
    ><code
      >void al_wait_for_event(ALLEGRO_EVENT_QUEUE *queue, ALLEGRO_EVENT *ret_event)
</code
      ></pre
    ><p
    >Wait until the event queue specified is non-empty. If <code
      >ret_event</code
      > is not NULL, the first event in the queue will be copied into <code
      >ret_event</code
      > and removed from the queue. If <code
      >ret_event</code
      > is NULL the first event is left at the head of the queue.</p
    ><p
    >See also: <a href="events.html#allegro_event"
      >ALLEGRO_EVENT</a
      >, <a href="events.html#al_wait_for_event_timed"
      >al_wait_for_event_timed</a
      >, <a href="events.html#al_wait_for_event_until"
      >al_wait_for_event_until</a
      ></p
    ><h1 id="al_wait_for_event_timed"
    ><a href="#TOC-al_wait_for_event_timed"
      >al_wait_for_event_timed</a
      ></h1
    ><pre
    ><code
      >bool al_wait_for_event_timed(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT *ret_event, float secs)
</code
      ></pre
    ><p
    >Wait until the event queue specified is non-empty. If <code
      >ret_event</code
      > is not NULL, the first event in the queue will be copied into <code
      >ret_event</code
      > and removed from the queue. If <code
      >ret_event</code
      > is NULL the first event is left at the head of the queue.</p
    ><p
    ><code
      >timeout_msecs</code
      > determines approximately how many seconds to wait. If the call times out, false is returned. Otherwise true is returned.</p
    ><p
    >See also: <a href="events.html#allegro_event"
      >ALLEGRO_EVENT</a
      >, <a href="events.html#al_wait_for_event"
      >al_wait_for_event</a
      >, <a href="events.html#al_wait_for_event_until"
      >al_wait_for_event_until</a
      ></p
    ><h1 id="al_wait_for_event_until"
    ><a href="#TOC-al_wait_for_event_until"
      >al_wait_for_event_until</a
      ></h1
    ><pre
    ><code
      >bool al_wait_for_event_until(ALLEGRO_EVENT_QUEUE *queue,
   ALLEGRO_EVENT *ret_event, ALLEGRO_TIMEOUT *timeout)
</code
      ></pre
    ><p
    >Wait until the event queue specified is non-empty. If <code
      >ret_event</code
      > is not NULL, the first event in the queue will be copied into <code
      >ret_event</code
      > and removed from the queue. If <code
      >ret_event</code
      > is NULL the first event is left at the head of the queue.</p
    ><p
    ><code
      >timeout</code
      > determines how long to wait. If the call times out, false is returned. Otherwise true is returned.</p
    ><p
    >See also: <a href="events.html#allegro_event"
      >ALLEGRO_EVENT</a
      >, <a href="time.html#allegro_timeout"
      >ALLEGRO_TIMEOUT</a
      >, <a href="time.html#al_init_timeout"
      >al_init_timeout</a
      >, <a href="events.html#al_wait_for_event"
      >al_wait_for_event</a
      >, <a href="events.html#al_wait_for_event_timed"
      >al_wait_for_event_timed</a
      ></p
    ></td>
</tr>
</table>


<p>
Last updated: 2009-09-13 09:23:20 UTC
</p>
</body
  ></html
>

